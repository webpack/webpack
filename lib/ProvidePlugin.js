/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
"use strict";

const ParserHelpers = require("./ParserHelpers");
const ConstDependency = require("./dependencies/ConstDependency");
const RuleSet = require("./RuleSet");
const NullFactory = require("./NullFactory");
const Uuid = require("uuid");

class ProvidePlugin {
	constructor(definitions, params) {
		this.definitions = definitions;
		this.identity = Uuid.v4();
		params = params || {};
		if (params.test || params.exclude || params.include) {
			this.condition = RuleSet.normalizeCondition({
				exclude: params.exclude,
				include: params.include,
				test: params.test
			});
		}
	}

	apply(compiler) {
		const definitions = this.definitions;
		compiler.hooks.compilation.tap(
			"ProvidePlugin",
			(compilation, { normalModuleFactory }) => {
				compilation.dependencyFactories.set(ConstDependency, new NullFactory());
				compilation.dependencyTemplates.set(
					ConstDependency,
					new ConstDependency.Template()
				);
				const handler = (parser, parserOptions) => {
					if (!this._isEnabledForParserOptions(parserOptions)) {
						return;
					}
					Object.keys(definitions).forEach(name => {
						var request = [].concat(definitions[name]);
						var splittedName = name.split(".");
						if (splittedName.length > 0) {
							splittedName.slice(1).forEach((_, i) => {
								const name = splittedName.slice(0, i + 1).join(".");
								parser.hooks.canRename
									.for(name)
									.tap("ProvidePlugin", ParserHelpers.approve);
							});
						}
						parser.hooks.expression.for(name).tap("ProvidePlugin", expr => {
							let nameIdentifier = name;
							const scopedName = name.includes(".");
							let expression = `require(${JSON.stringify(request[0])})`;
							if (scopedName) {
								nameIdentifier = `__webpack_provided_${name.replace(
									/\./g,
									"_dot_"
								)}`;
							}
							if (request.length > 1) {
								expression += request
									.slice(1)
									.map(r => `[${JSON.stringify(r)}]`)
									.join("");
							}
							if (
								!ParserHelpers.addParsedVariableToModule(
									parser,
									nameIdentifier,
									expression
								)
							) {
								return false;
							}
							if (scopedName) {
								ParserHelpers.toConstantDependency(parser, nameIdentifier)(
									expr
								);
							}
							return true;
						});
					});
				};
				normalModuleFactory.hooks.parser
					.for("javascript/auto")
					.tap("ProvidePlugin", handler);
				normalModuleFactory.hooks.parser
					.for("javascript/dynamic")
					.tap("ProvidePlugin", handler);
				// Disable ProvidePlugin for javascript/esm, see https://github.com/webpack/webpack/issues/7032
				normalModuleFactory.hooks.afterResolve.tap("ProvidePlugin", result => {
					let identities = this._getActiveProvidePlugins(result);
					result.parser = normalModuleFactory.getParser(result.type, {
						activeProvidePlugins: identities
					});
					this._saveActiveProvidePluginsToParser(result.parser, identities);
				});
			}
		);
	}

	/**
	 * Extracts the UUIDs of provide plugins that are active for the current request. This includes the UUIDs of all
	 * plugins that set themselves up previously, and the UUID of this plugin, if it is to be enabled.
	 *
	 * @private
	 * @param {Object} data - Request data after resolution.
	 * @returns {Array<string>} - The UUIDs of the active provide plugins for this request.
	 */
	_getActiveProvidePlugins(data) {
		const enabled = this._isEnabledForResource(data.resource);
		let activeIdentities =
			(data.parser.options && data.parser.options.activeProvidePlugins) || [];
		let ownIndex = activeIdentities.indexOf(this.identity);
		if (enabled && ownIndex === -1) {
			activeIdentities = activeIdentities.concat(this.identity);
		} else if (!enabled && ownIndex > -1) {
			activeIdentities = activeIdentities
				.slice(0, ownIndex)
				.concat(activeIdentities.slice(ownIndex + 1));
		}
		return activeIdentities;
	}

	/**
	 * @private
	 * @param {string} resource - Path of the resource to check.
	 * @returns {boolean} - Whether this plugin instance should be enabled for the mentioned resource.
	 */
	_isEnabledForResource(resource) {
		return !this.condition || this.condition(resource);
	}

	/**
	 * Parser options are transient by default. If multiple provide plugins are instantiated, it is necessary to record
	 * the list of active plugin UUIDs.
	 *
	 * @private
	 * @param {Object} parser - The parser generated by the normalModuleFactory
	 * @param {Array<string>} identities - The UUIDs of the currently active provide plugins.
	 * @returns {void}
	 */
	_saveActiveProvidePluginsToParser(parser, identities) {
		if (!parser.options) {
			parser.options = {};
		}
		parser.options.activeProvidePlugins = identities || [];
	}

	/**
	 * Examines the parser options to determine whether the plugin should operate on this parse operation.
	 *
	 * @private
	 * @param {Object} parserOptions - The parser options.
	 * @returns {boolean} - Whether imports for variables should be provided.
	 */
	_isEnabledForParserOptions(parserOptions) {
		if (parserOptions && parserOptions.activeProvidePlugins) {
			return parserOptions.activeProvidePlugins.indexOf(this.identity) > -1;
		}
		return false;
	}
}
module.exports = ProvidePlugin;
